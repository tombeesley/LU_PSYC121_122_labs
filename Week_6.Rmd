---
title: "PSYC121: Week 6 Lab"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE, exercise.startover = TRUE}
library(tidyverse)
library(learnr)
library(kableExtra)
load("data_clean.RData") # loads as "data"
dataQ = data[rep(1:20,11),] # duplicates the data, while in pilot form.
knitr::opts_chunk$set(echo = FALSE)
```

## Selecting columns from data

### The questionnaire data

We are going to take a look at the data from the questionnaire you completed in Week 1. The data is loaded into the exercises here, so we can look at it by simply calling it with the name "dataQ":

```{r dataQ, exercise = TRUE}
dataQ

```

This is quite a big dataset to work with. We can see the size of it in a couple of ways. First we can use the "dim" function to see the number of rows and the number of columns. We can also use the "colnames" function to see a list of the column names for the data:


```{r dimensions, exercise = TRUE}
dim(dataQ) # give the dimensions (rows,colums)
colnames(dataQ) # list the column names
```

## Selecting columns

Let's just take a few of these columns to work with in our exercises. To do this we can use the **"select"** command, which is part of [dplyr package](https://dplyr.tidyverse.org/reference/select.html) from the [tidyverse](https://tidyverse.org/) set of packages. To use this, specify the dataset you want to use (dataQ), and then the columns you want to select. To specify a list of columns, use the "c" function:

```{r select_1, exercise = TRUE}
select(dataQ, c(id,age,countries_visited,stroop_control,stroop_compatible,stroop_incompatible))

```
There are a couple of things that make this command a bit easier to work with. First, you can put the column names on a new line, to create an easier to read list. Anything after a comma in a function can be put on a new line. Secondly, if you need several columns in a row, you can use the colon (:) between the first and last column you need:

```{r select_2, exercise = TRUE}
select(dataQ, c(id,
                age,
                countries_visited,
                stroop_control:stroop_incompatible))

```

It's now your turn to try out the select command. Here you will select a new set of columns and create a new tibble from that selection. Include all of those listed in the last bit of code (you can copy that code if you like) but also add all of the data on social media. Store the result of this selection in a new variable called "dataQ_short".

```{r select_3, exercise = TRUE}


```

```{r select_3-hint-1}

dataQ_short <- select(dataQ, )

```

```{r select_3-solution}

dataQ_short <- select(dataQ, c(id,
                               age,
                               countries_visited,
                               stroop_control:stroop_incompatible,
                               facebook_days:twitter_follow))

dataQ_short # print out the result
```

Let's take a look at another selection of columns. Here we've made "data_short" have some different columns. Check which columns are in data_short using the "colnames" function.

```{r colnames_dataQ_short-setup}

dataQ_short <- select(dataQ, c(id,
                               age, 
                               gender,
                               facebook_days, 
                               instagram_days,
                               twitter_days))

```

```{r colnames_dataQ_short, exercise = TRUE, exercise.setup = "colnames_dataQ_short-setup"}

```
```{r colnames_dataQ_short-solution}
colnames(dataQ_short)
```

### Remove columns

We can remove a column using the select command, by using a "-" in front of any column names. Add a second statement to the code below to remove the "age" column from the data.  
```{r remove_select, exercise = TRUE, exercise.setup = "colnames_dataQ_short-setup"}
dataQ_short # print the data

```

```{r remove_select-solution}
dataQ_short # print the data

select(dataQ_short, -age)
```

## Filtering data

We've used select to reshape the data in terms of the columns, but we can also reshape and control the data we are working with in terms of the rows. To do this, we can use the **filter** command from [dplyr  package](https://dplyr.tidyverse.org/reference/filter.html). 

To use the filter, we simply specify the data first, and then we need to use an *expression* to state how we want the data to be filtered. For example:

```{r filter_example, exercise = TRUE}
filter(dataQ, age==27) # find all those people who are 27 years old
```

The following table gives some examples of very common expressions used in filtering data:

```{r}
tibble(Operator = c("==", 
                    "<", 
                    ">", 
                    "!", 
                    "&",
                    "|"),
       Meaning = c("is the same as",
                   "is less than",
                   "is greater than", 
                   "is not",
                   "and",
                   "or"),
       Example = c("filter(dataQ, age==27)",
                   "filter(dataQ, age<25)",
                   "filter(dataQ, age>30)",
                   "filter(dataQ, !gender == 'female')",
                   "filter(dataQ, age<30 & gender == 'female')",
                   "filter(dataQ, gender == 'male' | gender == 'non-binary')")) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = c("striped"))
```

It's particularly important to note the difference between "==" and "=" in R. "=" is used as an assignment operator - you've used it several times already inside functions (e.g., seq(from = 1, to = 10)). You can think of "=" as meaning "set this to". In contrast the double equals operator, "==", asks a question: "is this thing the same as this other thing?" In the above example, age==27, it looks for all rows in the data where age is the same value as 27. In programming terms, the expression returns a *boolean* value, which reports whether the statement is TRUE or FALSE (and when used in the filter, it finds all rows where it is TRUE). You can see this is in the results of the following "conditional expressions":

```{r binary_test, exercise = TRUE}
2 == 3
"blah" == "blah"
"blah" == "BLAH"
mean(seq(3,6)) == 4.5

```

Practice writing your own filter commands in the box below. Try to filter the data to match the following queries:

1. Data for all males AND who are taller than 170 cm.
2. Data for all people who used facebook for more than 2 days but less than 5 days a week.
3. Data for people who have visited more than 10 countries, AND are NOT female.

```{r filter_play, exercise = TRUE}

```
```{r filter_play-hint-1}
filter(dataQ, gender == "male" & <missing>)
```
```{r filter_play-hint-2}
filter(dataQ, facebook_days > <missing> & <missing>)
```
```{r filter_play-hint-3}
filter(dataQ, countries_visited <missing> & !gender == <missing>)
```
```{r filter_play-solution}
filter(dataQ, gender == "male" & height > 170)
filter(dataQ, facebook_days > 2 & facebook_days < 5)
filter(dataQ, countries_visited > 10 & !gender == "female")
```


## The pipe operator (%>%)

The select and filter commands are just some of the ways we can shape the data we are working with. As we move from the raw data, to the data of interest, we will build up a series of such commands to obtain the data that we are interested in. For example, we might want to first select some columns, and then filter the data:

```{r nonpipe, exercise = TRUE}
selected_dataQ <- select(dataQ, age:countries_visited) # select columns
filtered_selected_dataQ <- filter(selected_dataQ, age < 25) # filter rows
filtered_selected_dataQ # print out result
```

Note here that the result of the selection command becomes the dataset we use for the filter command. This means we need to create a new tibble to store the new selection, just to use this immediately in the filter. There's a better way to do this, using the **"pipe"** operator (%>%):

```{r pipe_example, exercise = TRUE}

dataQ %>% select(age:countries_visited) %>% filter(age < 25)

```
It might help to read the %>% as "send the result to". So we start with simply the tibble dataQ, and *send the result* (the tibble itself) to the select command, perform the select and *send the result to* the filter command, and perform the filter.

You can also put each step on a new line, which is very helpful when you have a long list of operations:

```{r pipe_example_newline, exercise = TRUE}

dataQ %>% 
  select(age:countries_visited) %>% 
  filter(age < 25)

```






